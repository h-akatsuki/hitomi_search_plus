// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.2.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `from_u8`, `new`, `score`, `text_score`
// These types are ignored because they are not used by any `pub` functions: `ClientTag`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `eq`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `count`, `name`, `types`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TagSuggest>>
abstract class TagSuggest implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<TagSuggest> newInstance({required String path}) =>
      RustLib.instance.api.crateApiSuggestTagSuggestNew(path: path);

  Future<TagsResult> suggest({required String query});

  Future<TagsResult> suggestWithType(
      {required String query, required TagType tagType});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TagsResult>>
abstract class TagsResult implements RustOpaqueInterface {
  int get len;

  set len(int len);

  static Future<TagsResult> empty() =>
      RustLib.instance.api.crateApiSuggestTagsResultEmpty();

  Future<Tag> getTag({required int index});
}

class Tag {
  final TagType tagType;
  final String name;
  final int count;

  const Tag({
    required this.tagType,
    required this.name,
    required this.count,
  });

  @override
  int get hashCode => tagType.hashCode ^ name.hashCode ^ count.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Tag &&
          runtimeType == other.runtimeType &&
          tagType == other.tagType &&
          name == other.name &&
          count == other.count;
}

enum TagType {
  artist,
  character,
  group,
  language,
  parody,
  type,
  female,
  male,
  tag,
  ;

  static Future<TagType?> fromText({required String s}) =>
      RustLib.instance.api.crateApiSuggestTagTypeFromText(s: s);
}
